<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 当然我在扯淡</title><link>https://mukhali.github.io/posts/</link><description>Recent content in Posts on 当然我在扯淡</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 22 May 2019 20:50:53 +0800</lastBuildDate><atom:link href="https://mukhali.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>华为2019年5月</title><link>https://mukhali.github.io/2019/%E5%8D%8E%E4%B8%BA2019%E5%B9%B45%E6%9C%88/</link><pubDate>Wed, 22 May 2019 20:50:53 +0800</pubDate><guid>https://mukhali.github.io/2019/%E5%8D%8E%E4%B8%BA2019%E5%B9%B45%E6%9C%88/</guid><description>0x00 引言 国家机器，个人信仰，公司理想。
0x01 华为极限生存 2019年05月15日，美国商务部在其官网发布一则新闻。表示BIS已经把华为公司加入Entity List（实体清单）， 理由是华为从事的活动违反了美国国家安全。进入这个名单后，很多美国公司无法向华为销售产品。之前中兴也是因 为这个原因，被撤换了管理层，缴纳了罚款。
因为技术封锁，华为启用了备胎芯片。
0x02 华为与联想 之后网上传言联想依据法律对华为断供。联想发布了好几份申明澄清事实。
0x03 华为与Google 路透社曝光称Google母公司Alphabet已按特朗普要求，停止与华为相关的业务和服务，涉及硬件、软件和技术服务方面，包括禁用Google服务。以后华为新设备将无法使用Google服务。
0x04 Github和Apache Apache 软件基金会官网上发布了EXPORTING ASF PRODUCTS，其中包括这么一句话：U.S. export laws and regulations apply to our distributions and remain in force as products and technology are re-exported to different parties and places around the world.
Github 全球最大源代码托管网站也发布了GitHub and Export Controls，其中包括这么一句话：GitHub.com, GitHub Enterprise Server, and the information you upload to either product may be subject to US export control laws, including U.</description></item><item><title>Ubuntu如何安装Docker-CE</title><link>https://mukhali.github.io/2019/ubuntu%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker-ce/</link><pubDate>Fri, 17 May 2019 20:44:27 +0800</pubDate><guid>https://mukhali.github.io/2019/ubuntu%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker-ce/</guid><description>0x00 引言 Docker 是我最喜欢的工具，但好像对我来是只是很好的工具，我不知道。
0x01 安装 Docker-CE Ubuntu 官方没有 Docker-CE，只能去使用 Docker 公司维护的库。具体添加方法如下：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable edge test&amp;quot; sudo apt update sudo apt install Docker-CE 先添加key，再添加库。
stable 是 Docker 公司的季度发布包。
edge 是 Docker 公司的月发布包。
test 是 Docker 公司的测试版。
比如到2019年05月22日为止， Ubuntu 19.04 还没有释放 stable， edge版Docker。但可以安装 test 版 Docker。
0x02 设置 通过下面命令来查看 Docker 运行状态。
sudo systemctl status docker # 查看 Docker 运行状态 默认是开启启动 Docker Deamon。我好像不喜欢这样，所以我会使用下面的命令禁止开机启动 Docker Deamon。</description></item><item><title>贝聿铭之苏州博物馆</title><link>https://mukhali.github.io/2019/%E8%B4%9D%E8%81%BF%E9%93%AD%E4%B9%8B%E8%8B%8F%E5%B7%9E%E5%8D%9A%E7%89%A9%E9%A6%86/</link><pubDate>Fri, 17 May 2019 20:17:37 +0800</pubDate><guid>https://mukhali.github.io/2019/%E8%B4%9D%E8%81%BF%E9%93%AD%E4%B9%8B%E8%8B%8F%E5%B7%9E%E5%8D%9A%E7%89%A9%E9%A6%86/</guid><description>0x00 引言 我可以封山，但还是会出作品。
0x01 狮子林 狮子林是苏州四大园林之一，始建与元代。狮子林在1917年是贝氏所有，贝氏引入西洋造园手法，将其建设成包括贝氏祠堂，贝氏族学等一体的园林。。贝聿铭出生在广东，小时候贝聿铭在这儿生活过，后来去了上海，去了美国留学。其父亲是中国银行创始人之一。
0x02 拙政园 拙政园也是苏州四大园林之一，始建于明朝，因王献臣官场失意而还乡。恩，狮子林往北不远也就是拙政园了。拙政园西边也就是苏州博物馆所在地了。苏州博物馆就是拆了一座医院和部分拙政园修建起来的。占地不是很大，但很耐看。苏州博物馆很舒服，光影和空间结构很好。
苏州博物馆很好看，就是太小，当然还有一个新馆也正在建设中。
0x04 后记 贝聿铭的作品还有法国卢浮宫的玻璃金字塔，香港中银大厦，南京六朝博物馆……。</description></item><item><title>OpenCV历史</title><link>https://mukhali.github.io/2019/opencv%E5%8E%86%E5%8F%B2/</link><pubDate>Thu, 25 Apr 2019 21:41:48 +0800</pubDate><guid>https://mukhali.github.io/2019/opencv%E5%8E%86%E5%8F%B2/</guid><description>0x00 引言 最近在看 OpenCV 好想用OpenCV 4，但考虑到生态，还是用 OpenCV 3.4.2。稍微了解了一下 OpenCV 的历史。这些年来，计算机视觉领域的新技术新方法不断涌现，指令集、编程语言和并行化技术越发先进，OpenCV 也在顺应潮流。
0x01 OpenCV 1.x 就像很多程序一样，OpenCV 是基于C语言开发。2006年10月发布1.0，其中已经有了random trees、boosted trees、neural nets等机器学习方法。
2008年10月1.1pre1发布，使用 VS2005构建，Python bindings支持Python 2.6，Linux下支持Octave bindings，在这一版本中加入了SURF、RANSAC、Fast approximate nearest neighbor search等，Face Detection (cvHaarDetectObjects)也变得更快。
0x02 OpenCV 2.x 代码量的增加，C++的流行，OpenCV 2.x发布时，其尽量使用C++而不是C，但是为了向前兼容，仍保留了对C API的支持。从2010年开始，2.x决定不再频繁支持和更新C API，而是focus在C++ API。
2009年9月2.0 beta发布，主要使用CMake构建，加入了很多新特征、描述子等，如FAST、LBP等。
2010年10月2.2版本发布，OpenCV的模块变成了大家熟悉的模样，像opencv_imgproc、opencv_features2d等，同时用opencv_contrib放置尚未成熟的代码，opencv_gpu放置使用CUDA加速的OpenCV函数。
2011年6月起的2.3.x版本、2012年4月起的2.4.x版本，一面增加新方法，一面修复bug，同时加强对GPU、Java for Android、 OpenCL、并行化的支持等等，OpenCV愈加稳定完善，值得注意的是 SIFT和SURF从2.4开始被放到了nonfree 模块（因为专利）。
考虑到过渡，OpenCV 2.4.x仍在维护，不过以后可能仅做bug修复和效率提升，不再增加新功能——鼓励向3.x迁移。
0x03 OpenCV 3.x 随着3.x的发布，1.x的C API将被淘汰不再被支持，以后C API可能通过C++源代码自动生成。3.x与2.x不完全兼容，与2.x相比，主要的不同之处在于OpenCV 3.x 的大部分方法都使用了OpenCL加速。3.x默认包含以及使用IPP，同时，matlab bindings、Face Recognition、SIFT、SURF、 text detector、motion templates &amp;amp; simple flow 等都移到了opencv_contrib下（opencv_contrib不仅存放了尚未稳定的代码，同时也存放了涉及专利保护的技术实现），大量涌现的新方法也包含在其中。
2017年8月3.3版本，2017年12月开始的3.4.x版本，opencv_dnn从opencv_contrib移至opencv，同时OpenCV开始支持C++ 11构建，之后明显感到对神经网络的支持在加强，opencv_dnn被持续改进和扩充。
0x04 OpenCV 4.</description></item><item><title>Win10和Ubuntu18.04多显卡的双系统安装</title><link>https://mukhali.github.io/2019/win10%E5%92%8Cubuntu18.04%E5%A4%9A%E6%98%BE%E5%8D%A1%E7%9A%84%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</link><pubDate>Thu, 18 Apr 2019 22:55:46 +0800</pubDate><guid>https://mukhali.github.io/2019/win10%E5%92%8Cubuntu18.04%E5%A4%9A%E6%98%BE%E5%8D%A1%E7%9A%84%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</guid><description>0x00 引言 东京大学入学祝词：等着你的，是个努力也得不到回报的社会。
爷爷说：在外面好好弄，莫担心他。(或许只有这些老人才让我有些动力，因为他们永远会觉得满足。)
0x01 场景 两块 SSD 硬盘，准备装 Win 10 和 Ubuntu 18.04 双系统，每块硬盘分两个区：EFI 引导区和系统盘。
先安装Win 10系统，后安装 Ubuntu 18.04。
0x02 卡着 Win 10 好安装，但当安装 Ubuntu 18.04 的时候会卡在 GUI 界面，鼠标和键盘都不能动。所以需要在 Ubuntu 进入 install Ubuntu 界面的时候按 e 键，将第二行的 quiet splash - - - 修改成 quiet splash nomodeset。nomodeset表示用电脑集显来进行显示。然后按F10继续安装。
0x03 安装驱动 安装好系统后，就需要安装显卡驱动了，要不然下次启动系统的时候又很慢。安装驱动大概有三种方法，选择一个有效 的就可以，不需要三个都用。
sudo apt-get update -y sudo apt-get upgrade -y ubuntu-drivers devices sudo ubuntu-drivers autoinstall sudo reboot sudo apt-get update -y sudo apt-get upgrade -y sudo add-apt-repository -y ppa:graphics-drivers/ppa sudo apt-get update -y sudo ubuntu-drivers autoinstall sudo reboot 从官方下载驱动安装 0x04 双启 安装好之后，每次启动还是只能进入 Ubuntu 系统，需要将 Win 10 加入 Ubuntu 的引导。</description></item><item><title>北京，那些值得闲逛的地方</title><link>https://mukhali.github.io/2019/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8C%97%E4%BA%AC/</link><pubDate>Sun, 14 Apr 2019 14:26:32 +0800</pubDate><guid>https://mukhali.github.io/2019/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8C%97%E4%BA%AC/</guid><description>0x00 引言 旅游最好的方法：买几本书，去那儿看365个日出。
0x01 故宫 很多人来北京了纠结去哪儿？我最推荐去的地方要数故宫了。故宫是一根针线，能串起好多好多，对于是好多什么，我无法知道你的答案。故宫会给每个人不一样的答案。
故宫是一座皇城，就像英国的白金汉宫，法过的凡尔赛宫一样，是帝王起居和办公的地方。现在的故宫格局继承于明朝永乐帝。现在的北京城如果和南城这座旧城来比是一座重新规划的城市。
0x02 国博 国博就是国家博物馆，是集全国之力全力建设的国家博物馆。去故宫不能预测你能看到什么，但去国博我大概能知道你能看到什么。国博是建国10周年的献礼之一，线索就是这个国家上下五千年，从夏商周，到改革开放。
0x03 恭王府 恭王府原是和第，和珅府邸。和珅跌倒，嘉庆吃饱。嘉庆赏赐给了王爷，这座和珅全力营造的府邸从此也就成了王府。
恭王府旁边是有着白塔的北海，北海也是曾经老炮儿解决问题的地方、有前海、当然也有史铁生积蓄力量的什刹海。旁边更有皇家园林：颐和园、圆明园。恭王府的位置是真的好。
你如果去韩国看了皇宫，你就会觉得恭王府比你觉得的还要好。恭王府还曾是“鬼子六”的府邸。
0x04 国子监 国子监旁边就是出了两位清帝王的雍和宫。雍和宫旁边低矮的老北京民房，衬托出雍和宫的高大。
国子监又称“太学”，以前能再国子监读书的学生称为“监生”。国子监在以前应该是相当于人民大学？当然也有可能是北大清华？我上学的东山书院相当于现在的初高中吧。
国子监旁边是孔庙，孔庙作为精神上独尊儒术的物质存在，那儿的一板一眼还是值得看看。那附近的下马石也是为孔庙安置的。
0x05 奥体 古代未必差，现代也未必差。看过了过往，被满眼低矮的北京老民居厌恶了的精神，你该去奥体，那儿为奥运会展现了很多现代的东西：鸟巢、水立方。当然当年未来恢复北京中轴线发了很大力气的。奥体也属于中轴线的一部分。
奥森那儿好多跑步的，周末好去处，最好的季节还是春秋。北京的秋是出了名的好，加上营造二字那就更了得。
0x06 城墙 北京的城墙很高大，作为帝都，它的城墙是最完善，最雄伟，最完整的。奥，对了，那是以前的时候，现在想看城墙就不必来北京了，你去买张西安票。北京曾经有外城、内城和皇城三重城墙。
0x07 碎碎念 北京前门火车站应该很有意思，只是好像进不去。
中关村原名“中官村”，是李莲英等买来作为退休太监的墓园的地方。
记得曾经有人说过：成名要趁早。
长城也可以去看，看长城看的不是长或者城，看的是山势。</description></item><item><title>Cpp语言回调函数</title><link>https://mukhali.github.io/2019/cpp%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 19 Feb 2019 23:04:40 +0800</pubDate><guid>https://mukhali.github.io/2019/cpp%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description> 0x00 引言 想注册一个公众号，我好像文笔不是很好，我有很多内容可写，时间和文笔去哪儿找。
Pytorch 1.0 才发布不久，但整个机器学习领域很成熟了，可以弥补不足。
0x01 函数指针 struct IDataReader { virtual void ReadCallbackFunc(std::string topicName) = 0; }; class Subscriber { public: Subscriber(); ~Subscriber(); bool SetCallback(IDataReader* iReader) { _process = iReader; _process(&amp;quot;callback&amp;quot;); return true; } private: IDataReader * _process; }; 0x02 Cpp调用 具体代码如下：
class Example_Subscriber : IDataReader { public: Example_Subscriber() {}; ~Example_Subscriber(); void example_subscriber_main(); void CallbackFunc(std::string topicName); private: Subscriber * subscriberPtr; }; Example_Subscriber::Example_Subscriber() { subscriberPtr = new Subscriber(); } Example_Subscriber::~Example_Subscriber() { delete subscriberPtr; } void Example_Subscriber::example_subscriber_main() { subscriberPtr-&amp;gt;SetCallback(this); } void Example_Subscriber::CallbackFunc(std::string topicName) { printf(topicName); } int main() { Example_Subscriber * sub = new Example_Subscriber(); sub-&amp;gt;subscriber_main(); } 0x03 UPDATE 2019-03-01</description></item><item><title>C语言回调函数</title><link>https://mukhali.github.io/2019/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 19 Feb 2019 22:00:21 +0800</pubDate><guid>https://mukhali.github.io/2019/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 函数指针 C语言的回调函数主要通过函数指针的方式实现，相关主要代码如下：
typedef void(*CallbackFunc)(int mes_length); void callback(int mes_length) // 回调函数 { std::cout &amp;lt;&amp;lt; mes_length &amp;lt;&amp;lt;std::endl; } extern &amp;quot;C&amp;quot; void __declspec(dllimport) SetReadCallback(CallbackFunc callback) // 调用函数 { int length = 0; callback(length); } int main(int argc,char* argv[]) // 实现函数回调 { SetReadCallback(callback); return 0; } 0x02 C调用 void callback(int mes_length) { std::cout &amp;lt;&amp;lt; mes_length &amp;lt;&amp;lt;std::endl; } int main() { SetReadCallback(callback); return 0; } 0x03 C#调用 C#这边主要通过委托（delegate）来实现，具体代码如下：</description></item><item><title>C#调用Cpp语言DLL</title><link>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8cpp%E8%AF%AD%E8%A8%80dll/</link><pubDate>Mon, 18 Feb 2019 22:37:25 +0800</pubDate><guid>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8cpp%E8%AF%AD%E8%A8%80dll/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 Cpp工程 CppMath.h
#pragma once #include &amp;lt;stdexcept&amp;gt; class CppMath { public: double Add(double arg1,double arg2); }; CppMath.cpp
#pragma once #include &amp;quot;CppMath.h&amp;quot; double CppMath::Add(double arg1,double arg2) { return arg1+arg2; } 0x02 CLR Wrapper工程 CLRWrapper.h
#pragma once #include &amp;quot;CppMath.h&amp;quot; using namespace System; namespace CLRWrapper { public ref class CppMathWrapper { public: //ctor CppMathWrapper(); //Methods double Add(double arg1,double arg2); private: CppMath *cppMath; }; } CLRWrapper.</description></item><item><title>C#调用C语言DLL</title><link>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80dll/</link><pubDate>Mon, 18 Feb 2019 22:09:25 +0800</pubDate><guid>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80dll/</guid><description> 0x00 引言 再简单的事情，也需要有人去做。
0x01 .h文件 demo.h
extern &amp;quot;C&amp;quot; __declspec(dllexport) double Add(double a, double b); 0x02 .cpp文件 demo.cpp
double Add( double a, double b ) { return a+b; } 0x03 C#实现 prograss.cs
using System.Runtime.InteropServices; [DllImport(&amp;quot;MathFuncsDll.dll&amp;quot;, CallingConvention=CallingConvention.Cdecl)] public static extern double Add(double a, double b); public static void main() { c = Add(c, c); } 0x04 UPDATE 2019-02-18</description></item><item><title>Golang的面向对象</title><link>https://mukhali.github.io/2019/golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 13 Jan 2019 17:22:39 +0800</pubDate><guid>https://mukhali.github.io/2019/golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 成员变量 type Person struct { name string age int } person := Person{&amp;quot;mike&amp;quot;,18} fmt.Println(person) 0x02 成员函数 func (person *Person) showInfo() { fmt.Printf(&amp;quot;My name is %s , age is %d &amp;quot;,person.name,person.age) } func (person *Person) setAge(age int) { person.age = age } person := Person{&amp;quot;mike&amp;quot;,18} person.showInfo() person.setAge(20) fmt,Println(person) 0x03 继承 没有关键字的继承。
type Student struct { Person id int score int } func (student *Student) showInfo() { fmt.</description></item><item><title>Golang操作Sqlite</title><link>https://mukhali.github.io/2019/golang%E6%93%8D%E4%BD%9Csqlite/</link><pubDate>Sun, 13 Jan 2019 11:08:30 +0800</pubDate><guid>https://mukhali.github.io/2019/golang%E6%93%8D%E4%BD%9Csqlite/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 代码 package main import ( &amp;quot;database/sql&amp;quot; &amp;quot;fmt&amp;quot; _ &amp;quot;github.com/mattn/go-sqlite3&amp;quot; &amp;quot;os&amp;quot; ) func main() { type Person struct { name string age int } person := Person{&amp;quot;mike&amp;quot;,18} fmt.Println(person) os.Remove(&amp;quot;./foo.db&amp;quot;) db, err := sql.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;./foo.db&amp;quot;) checkErr(err) defer db.Close() //插入数据 _, err = db.Exec(&amp;quot;create table userinfo (uid text not null primary key, username text, departname text, created text)&amp;quot;) checkErr(err) stmt, err := db.Prepare(&amp;quot;INSERT INTO userinfo(uid, username, departname, created) values(?</description></item><item><title>Sqlite3数据库合并</title><link>https://mukhali.github.io/2019/sqlite3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E5%B9%B6/</link><pubDate>Wed, 09 Jan 2019 16:02:17 +0800</pubDate><guid>https://mukhali.github.io/2019/sqlite3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E5%B9%B6/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 需求 存在多个数据库，需要合并，数据库中相同表的结构是一样的。 主要是使用了Sqlite3的系统表sqlite_master。
0x02 Python 代码 # coding=utf-8 import sys, sqlite3, os def merge_tables(tables_file_a, tables_file_b, con_file_a): print(&amp;quot;Start Merge Tables&amp;quot;) j = 0 while j &amp;lt; len(tables_file_b): if not tables_file_b[j] in tables_file_a: cur_table_file_a = con_file_a.cursor() try: cur_table_file_a.execute(tables_file_b[j][3:-3]) except: print(&amp;quot;Error: &amp;quot; + tables_file_b[j][3:-3]) j += 1 else: j += 1 print(&amp;quot;All Tables Merged!&amp;quot;) def merge_index(tables_file_a, tables_file_b, con_file_a): print(&amp;quot;Start Merge Index&amp;quot;) j = 0 while j &amp;lt; len(tables_file_b): if not tables_file_b[j] in tables_file_a: cur_table_file_a = con_file_a.</description></item><item><title>2018年的杂记</title><link>https://mukhali.github.io/2018/2018%E5%B9%B4de%E6%9D%82%E8%AE%B0/</link><pubDate>Mon, 31 Dec 2018 17:08:39 +0800</pubDate><guid>https://mukhali.github.io/2018/2018%E5%B9%B4de%E6%9D%82%E8%AE%B0/</guid><description>0x00 引言 每个人都有缺点，我也不例外。
0x01 只言片语 又是一年过去了，我也已经过三十了。
今年自己想做的都做了吗？好像没有，只是时间已经流逝。
回头看毕业两年，未来该怎么走？我不知道，我只知道我该往前使劲走。
如果我是一匹野马，自该有自己的草原，如果没有，我将去寻找。
2018 电脑、手机……
2019年我该往哪儿使劲？
我一定要去做云开发，基于Golang……寻找自己的草原
努力去做吧，谁又曾知道。</description></item><item><title>洗衣机的选择</title><link>https://mukhali.github.io/2018/%E6%B4%97%E8%A1%A3%E6%9C%BAde%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 31 Dec 2018 11:19:37 +0800</pubDate><guid>https://mukhali.github.io/2018/%E6%B4%97%E8%A1%A3%E6%9C%BAde%E9%80%89%E6%8B%A9/</guid><description> 0x00 引言 以前不懂，以后就懂了。
0x01 关于洗衣机 店里的洗衣机停工快一年了，最近天气变冷，在给店了挑选洗衣机。以前不懂洗衣机器，最近查了一下，考虑到空间和合用性，最后选了海尔。
市场上的情况是：海尔洗衣机市场占有率第一、小天鹅专做洗衣机，18年被美的收购、容声是做冰箱出身的。
洗衣机可以分两类：波轮式和滚筒式。我喜欢滚筒样式。
我以前不懂，以后就懂了。
0x2 UPDATE 2018-12-31</description></item><item><title>Emacs喜欢神器</title><link>https://mukhali.github.io/2016/emacs%E5%96%9C%E6%AC%A2%E7%A5%9E%E5%99%A8/</link><pubDate>Tue, 08 Mar 2016 20:19:37 +0800</pubDate><guid>https://mukhali.github.io/2016/emacs%E5%96%9C%E6%AC%A2%E7%A5%9E%E5%99%A8/</guid><description>0x00 引言 Emacs是一个操作系统级别Editor，最初由Richard Stallman(理查德·马修·斯托曼)于1975年在MIT协同Guy Steele共同完成。很可能有人喜欢UNIX哲学，而讨厌Emacs这种包含万物的行为。而我会说“我喜欢UNIX哲学，也拥抱Emacs”。
0x01 Appointment 在diary文件中编辑你的安排如下
Monday 8:00am 该工作咯 3:00pm 看会儿paper Tuesday 8:00am 该工作咯 3:00pm 看会儿paper Wednesday 8:00am 该工作咯 3:00pm 看会儿paper Thursday 8:00am 该工作咯 3:00pm 看会儿paper Friday 8:00am 该工作咯 3:00pm 看会儿paper * 1 清理一遍阅读列表，学习一个新主题 在你自己的配置文件中添加以下代码：
(global-set-key (kbd &amp;quot;&amp;lt;f9&amp;gt;&amp;quot;) &#39;(lambda () (interactive) (progn (if (not (featurep &#39;appt)) (appt-activate) (unless appt-timer (appt-activate))) ))) ;quick access to Calendar and Diary 每次打开Emacs的时候，按f9就能激活提醒了。
0x02 Calendar 在生活中总有些节日不能错过， 在过往的时间中总有些日子不能忘怀， 在这世间总有些人不能不挂念，</description></item><item><title>Git喜欢版本管理</title><link>https://mukhali.github.io/2016/git%E5%96%9C%E6%AC%A2%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 19 Jan 2016 09:51:04 +0800</pubDate><guid>https://mukhali.github.io/2016/git%E5%96%9C%E6%AC%A2%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</guid><description>0x00 引言 Git是一个分布式版本控制／软件配置管理软件，原是Linux内核开发者林纳斯·托瓦兹（Linus Torvalds）为更好地管理Linux内核开发而设计。本文记录了一些基本概念和基本操作，当然关于使用 Git 最重要的其实不是明白这些，而是掌握一些Git的使用模式。 当你用上了Git，其它那些版本管理系统真的不想再动了。Git是我最喜欢的工具之一，另一个就是Emacs。
0x01 关键字 HEAD：指针 工作区 版本库(working tree) 暂存区(index)：add命令将文件添加到暂存区 已跟踪(staging)（未更新、已修改、已放入暂存区） 未跟踪(unstage) 仓库：commit将文件从暂存区添加到仓库 0x02 版本管理可以细分为 本地分支管理、远程分支管理、补丁管理、暂存（index）管理、
0x03 安装 如果你是在Debian，Ubuntu系统中，那么你可以通过下面命令安装：
sudo apt-get install git 如果你是在Red Hat，Fedora系统中，那么你可以通过下面命令安装：
sudo yum install git 我是通过下面这条命令来安装的：
pacman -S git 0x04 配置 git config --global user.name &amp;quot;name&amp;quot; git config --global user.email &amp;quot;name@gmail.com&amp;quot; git config --global color.ui true git config core.ignorecase false git config -l #list all the Git config 这样配置完后，保存在~/.</description></item></channel></rss>