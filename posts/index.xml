<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 当然我在扯淡</title><link>https://mukhali.github.io/posts/</link><description>Recent content in Posts on 当然我在扯淡</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 17 May 2019 20:44:27 +0800</lastBuildDate><atom:link href="https://mukhali.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Ubuntu如何安装Docker-CE</title><link>https://mukhali.github.io/2019/ubuntu%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker-ce/</link><pubDate>Fri, 17 May 2019 20:44:27 +0800</pubDate><guid>https://mukhali.github.io/2019/ubuntu%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85docker-ce/</guid><description>0x00 引言 Docker 是我最喜欢的工具，但好像对我来是只是很好的工具，我不知道。
0x01 安装 Docker-CE Ubuntu 官方没有 Docker-CE，只能去使用 Docker 公司维护的库。具体添加方法如下：
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable edge test&amp;quot; sudo apt update sudo apt install Docker-CE 先添加key，再添加库。
stable 是 Docker 公司的季度发布包。
edge 是 Docker 公司的月发布包。
test 是 Docker 公司的测试版。
比如到2019年05月22日为止， Ubuntu 19.04 还没有释放 stable， edge版Docker。但可以安装 test 版 Docker。
0x02 设置 通过下面命令来查看 Docker 运行状态。
sudo systemctl status docker # 查看 Docker 运行状态 默认是开启启动 Docker Deamon。我好像不喜欢这样，所以我会使用下面的命令禁止开机启动 Docker Deamon。</description></item><item><title>北京，那些值得闲逛的地方</title><link>https://mukhali.github.io/2019/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8C%97%E4%BA%AC/</link><pubDate>Sun, 14 Apr 2019 14:26:32 +0800</pubDate><guid>https://mukhali.github.io/2019/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%8C%97%E4%BA%AC/</guid><description>0x00 引言 旅游最好的方法：买几本书，去那儿看365个日出。
0x01 故宫 很多人来北京了纠结去哪儿？我最推荐去的地方要数故宫了。故宫是一根针线，能串起好多好多，对于是好多什么，我无法知道你的答案。故宫会给每个人不一样的答案。
故宫是一座皇城，就像英国的白金汉宫，法过的凡尔赛宫一样，是帝王起居和办公的地方。现在的故宫格局继承于明朝永乐帝。现在的北京城如果和南城这座旧城来比是一座重新规划的城市。
0x02 国博 国博就是国家博物馆，是集全国之力全力建设的国家博物馆。去故宫不能预测你能看到什么，但去国博我大概能知道你能看到什么。国博是建国10周年的献礼之一，线索就是这个国家上下五千年，从夏商周，到改革开放。
0x03 恭王府 恭王府原是和第，和珅府邸。和珅跌倒，嘉庆吃饱。嘉庆赏赐给了王爷，这座和珅全力营造的府邸从此也就成了王府。
恭王府旁边是有着白塔的北海，北海也是曾经老炮儿解决问题的地方、有前海、当然也有史铁生积蓄力量的什刹海。旁边更有皇家园林：颐和园、圆明园。恭王府的位置是真的好。
你如果去韩国看了皇宫，你就会觉得恭王府比你觉得的还要好。恭王府还曾是“鬼子六”的府邸。
0x04 国子监 国子监旁边就是出了两位清帝王的雍和宫。雍和宫旁边低矮的老北京民房，衬托出雍和宫的高大。
国子监又称“太学”，以前能再国子监读书的学生称为“监生”。国子监在以前应该是相当于人民大学？当然也有可能是北大清华？我上学的东山书院相当于现在的初高中吧。
国子监旁边是孔庙，孔庙作为精神上独尊儒术的物质存在，那儿的一板一眼还是值得看看。那附近的下马石也是为孔庙安置的。
0x05 奥体 古代未必差，现代也未必差。看过了过往，被满眼低矮的北京老民居厌恶了的精神，你该去奥体，那儿为奥运会展现了很多现代的东西：鸟巢、水立方。当然当年未来恢复北京中轴线发了很大力气的。奥体也属于中轴线的一部分。
奥森那儿好多跑步的，周末好去处，最好的季节还是春秋。北京的秋是出了名的好，加上营造二字那就更了得。
0x06 城墙 北京的城墙很高大，作为帝都，它的城墙是最完善，最雄伟，最完整的。奥，对了，那是以前的时候，现在想看城墙就不必来北京了，你去买张西安票。北京曾经有外城、内城和皇城三重城墙。
0x07 碎碎念 北京前门火车站应该很有意思，只是好像进不去。
中关村原名“中官村”，是李莲英等买来作为退休太监的墓园的地方。
记得曾经有人说过：成名要趁早。
长城也可以去看，看长城看的不是长或者城，看的是山势。</description></item><item><title>Cpp语言回调函数</title><link>https://mukhali.github.io/2019/cpp%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 19 Feb 2019 23:04:40 +0800</pubDate><guid>https://mukhali.github.io/2019/cpp%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description> 0x00 引言 想注册一个公众号，我好像文笔不是很好，我有很多内容可写，时间和文笔去哪儿找。
Pytorch 1.0 才发布不久，但整个机器学习领域很成熟了，可以弥补不足。
0x01 函数指针 struct IDataReader { virtual void ReadCallbackFunc(std::string topicName) = 0; }; class Subscriber { public: Subscriber(); ~Subscriber(); bool SetCallback(IDataReader* iReader) { _process = iReader; _process(&amp;quot;callback&amp;quot;); return true; } private: IDataReader * _process; }; 0x02 Cpp调用 具体代码如下：
class Example_Subscriber : IDataReader { public: Example_Subscriber() {}; ~Example_Subscriber(); void example_subscriber_main(); void CallbackFunc(std::string topicName); private: Subscriber * subscriberPtr; }; Example_Subscriber::Example_Subscriber() { subscriberPtr = new Subscriber(); } Example_Subscriber::~Example_Subscriber() { delete subscriberPtr; } void Example_Subscriber::example_subscriber_main() { subscriberPtr-&amp;gt;SetCallback(this); } void Example_Subscriber::CallbackFunc(std::string topicName) { printf(topicName); } int main() { Example_Subscriber * sub = new Example_Subscriber(); sub-&amp;gt;subscriber_main(); } 0x03 UPDATE 2019-03-01</description></item><item><title>C语言回调函数</title><link>https://mukhali.github.io/2019/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 19 Feb 2019 22:00:21 +0800</pubDate><guid>https://mukhali.github.io/2019/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 函数指针 C语言的回调函数主要通过函数指针的方式实现，相关主要代码如下：
typedef void(*CallbackFunc)(int mes_length); void callback(int mes_length) // 回调函数 { std::cout &amp;lt;&amp;lt; mes_length &amp;lt;&amp;lt;std::endl; } extern &amp;quot;C&amp;quot; void __declspec(dllimport) SetReadCallback(CallbackFunc callback) // 调用函数 { int length = 0; callback(length); } int main(int argc,char* argv[]) // 实现函数回调 { SetReadCallback(callback); return 0; } 0x02 C调用 void callback(int mes_length) { std::cout &amp;lt;&amp;lt; mes_length &amp;lt;&amp;lt;std::endl; } int main() { SetReadCallback(callback); return 0; } 0x03 C#调用 C#这边主要通过委托（delegate）来实现，具体代码如下：</description></item><item><title>C#调用Cpp语言DLL</title><link>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8cpp%E8%AF%AD%E8%A8%80dll/</link><pubDate>Mon, 18 Feb 2019 22:37:25 +0800</pubDate><guid>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8cpp%E8%AF%AD%E8%A8%80dll/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 Cpp工程 CppMath.h
#pragma once #include &amp;lt;stdexcept&amp;gt; class CppMath { public: double Add(double arg1,double arg2); }; CppMath.cpp
#pragma once #include &amp;quot;CppMath.h&amp;quot; double CppMath::Add(double arg1,double arg2) { return arg1+arg2; } 0x02 CLR Wrapper工程 CLRWrapper.h
#pragma once #include &amp;quot;CppMath.h&amp;quot; using namespace System; namespace CLRWrapper { public ref class CppMathWrapper { public: //ctor CppMathWrapper(); //Methods double Add(double arg1,double arg2); private: CppMath *cppMath; }; } CLRWrapper.</description></item><item><title>C#调用C语言DLL</title><link>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80dll/</link><pubDate>Mon, 18 Feb 2019 22:09:25 +0800</pubDate><guid>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80dll/</guid><description> 0x00 引言 再简单的事情，也需要有人去做。
0x01 .h文件 demo.h
extern &amp;quot;C&amp;quot; __declspec(dllexport) double Add(double a, double b); 0x02 .cpp文件 demo.cpp
double Add( double a, double b ) { return a+b; } 0x03 C#实现 prograss.cs
using System.Runtime.InteropServices; [DllImport(&amp;quot;MathFuncsDll.dll&amp;quot;, CallingConvention=CallingConvention.Cdecl)] public static extern double Add(double a, double b); public static void main() { c = Add(c, c); } 0x04 UPDATE 2019-02-18</description></item><item><title>Golang的面向对象</title><link>https://mukhali.github.io/2019/golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 13 Jan 2019 17:22:39 +0800</pubDate><guid>https://mukhali.github.io/2019/golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 成员变量 type Person struct { name string age int } person := Person{&amp;quot;mike&amp;quot;,18} fmt.Println(person) 0x02 成员函数 func (person *Person) showInfo() { fmt.Printf(&amp;quot;My name is %s , age is %d &amp;quot;,person.name,person.age) } func (person *Person) setAge(age int) { person.age = age } person := Person{&amp;quot;mike&amp;quot;,18} person.showInfo() person.setAge(20) fmt,Println(person) 0x03 继承 没有关键字的继承。
type Student struct { Person id int score int } func (student *Student) showInfo() { fmt.</description></item><item><title>Golang操作Sqlite</title><link>https://mukhali.github.io/2019/golang%E6%93%8D%E4%BD%9Csqlite/</link><pubDate>Sun, 13 Jan 2019 11:08:30 +0800</pubDate><guid>https://mukhali.github.io/2019/golang%E6%93%8D%E4%BD%9Csqlite/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 代码 package main import ( &amp;quot;database/sql&amp;quot; &amp;quot;fmt&amp;quot; _ &amp;quot;github.com/mattn/go-sqlite3&amp;quot; &amp;quot;os&amp;quot; ) func main() { type Person struct { name string age int } person := Person{&amp;quot;mike&amp;quot;,18} fmt.Println(person) os.Remove(&amp;quot;./foo.db&amp;quot;) db, err := sql.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;./foo.db&amp;quot;) checkErr(err) defer db.Close() //插入数据 _, err = db.Exec(&amp;quot;create table userinfo (uid text not null primary key, username text, departname text, created text)&amp;quot;) checkErr(err) stmt, err := db.Prepare(&amp;quot;INSERT INTO userinfo(uid, username, departname, created) values(?</description></item><item><title>Sqlite3数据库合并</title><link>https://mukhali.github.io/2019/sqlite3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E5%B9%B6/</link><pubDate>Wed, 09 Jan 2019 16:02:17 +0800</pubDate><guid>https://mukhali.github.io/2019/sqlite3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E5%B9%B6/</guid><description>0x00 引言 再简单的事情，也需要有人去做。
0x01 需求 存在多个数据库，需要合并，数据库中相同表的结构是一样的。 主要是使用了Sqlite3的系统表sqlite_master。
0x02 Python 代码 # coding=utf-8 import sys, sqlite3, os def merge_tables(tables_file_a, tables_file_b, con_file_a): print(&amp;quot;Start Merge Tables&amp;quot;) j = 0 while j &amp;lt; len(tables_file_b): if not tables_file_b[j] in tables_file_a: cur_table_file_a = con_file_a.cursor() try: cur_table_file_a.execute(tables_file_b[j][3:-3]) except: print(&amp;quot;Error: &amp;quot; + tables_file_b[j][3:-3]) j += 1 else: j += 1 print(&amp;quot;All Tables Merged!&amp;quot;) def merge_index(tables_file_a, tables_file_b, con_file_a): print(&amp;quot;Start Merge Index&amp;quot;) j = 0 while j &amp;lt; len(tables_file_b): if not tables_file_b[j] in tables_file_a: cur_table_file_a = con_file_a.</description></item><item><title>2018年的杂记</title><link>https://mukhali.github.io/2018/2018%E5%B9%B4de%E6%9D%82%E8%AE%B0/</link><pubDate>Mon, 31 Dec 2018 17:08:39 +0800</pubDate><guid>https://mukhali.github.io/2018/2018%E5%B9%B4de%E6%9D%82%E8%AE%B0/</guid><description>0x00 引言 每个人都有缺点，我也不例外。
0x01 只言片语 又是一年过去了，我也已经过三十了。
今年自己想做的都做了吗？好像没有，只是时间已经流逝。
回头看毕业两年，未来该怎么走？我不知道，我只知道我该往前使劲走。
如果我是一匹野马，自该有自己的草原，如果没有，我将去寻找。
2018 电脑、手机……
2019年我该往哪儿使劲？
我一定要去做云开发，基于Golang……寻找自己的草原
努力去做吧，谁又曾知道。</description></item><item><title>洗衣机的选择</title><link>https://mukhali.github.io/2018/%E6%B4%97%E8%A1%A3%E6%9C%BAde%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 31 Dec 2018 11:19:37 +0800</pubDate><guid>https://mukhali.github.io/2018/%E6%B4%97%E8%A1%A3%E6%9C%BAde%E9%80%89%E6%8B%A9/</guid><description> 0x00 引言 以前不懂，以后就懂了。
0x01 关于洗衣机 店里的洗衣机停工快一年了，最近天气变冷，在给店了挑选洗衣机。以前不懂洗衣机器，最近查了一下，考虑到空间和合用性，最后选了海尔。
市场上的情况是：海尔洗衣机市场占有率第一、小天鹅专做洗衣机，18年被美的收购、容声是做冰箱出身的。
洗衣机可以分两类：波轮式和滚筒式。我喜欢滚筒样式。
我以前不懂，以后就懂了。
0x2 UPDATE 2018-12-31</description></item><item><title>Emacs喜欢神器</title><link>https://mukhali.github.io/2016/emacs%E5%96%9C%E6%AC%A2%E7%A5%9E%E5%99%A8/</link><pubDate>Tue, 08 Mar 2016 20:19:37 +0800</pubDate><guid>https://mukhali.github.io/2016/emacs%E5%96%9C%E6%AC%A2%E7%A5%9E%E5%99%A8/</guid><description>0x00 引言 Emacs是一个操作系统级别Editor，最初由Richard Stallman(理查德·马修·斯托曼)于1975年在MIT协同Guy Steele共同完成。很可能有人喜欢UNIX哲学，而讨厌Emacs这种包含万物的行为。而我会说“我喜欢UNIX哲学，也拥抱Emacs”。
0x01 Appointment 在diary文件中编辑你的安排如下
Monday 8:00am 该工作咯 3:00pm 看会儿paper Tuesday 8:00am 该工作咯 3:00pm 看会儿paper Wednesday 8:00am 该工作咯 3:00pm 看会儿paper Thursday 8:00am 该工作咯 3:00pm 看会儿paper Friday 8:00am 该工作咯 3:00pm 看会儿paper * 1 清理一遍阅读列表，学习一个新主题 在你自己的配置文件中添加以下代码：
(global-set-key (kbd &amp;quot;&amp;lt;f9&amp;gt;&amp;quot;) &#39;(lambda () (interactive) (progn (if (not (featurep &#39;appt)) (appt-activate) (unless appt-timer (appt-activate))) ))) ;quick access to Calendar and Diary 每次打开Emacs的时候，按f9就能激活提醒了。
0x02 Calendar 在生活中总有些节日不能错过， 在过往的时间中总有些日子不能忘怀， 在这世间总有些人不能不挂念，</description></item><item><title>Git喜欢版本管理</title><link>https://mukhali.github.io/2016/git%E5%96%9C%E6%AC%A2%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 19 Jan 2016 09:51:04 +0800</pubDate><guid>https://mukhali.github.io/2016/git%E5%96%9C%E6%AC%A2%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</guid><description>0x00 引言 Git是一个分布式版本控制／软件配置管理软件，原是Linux内核开发者林纳斯·托瓦兹（Linus Torvalds）为更好地管理Linux内核开发而设计。本文记录了一些基本概念和基本操作，当然关于使用 Git 最重要的其实不是明白这些，而是掌握一些Git的使用模式。 当你用上了Git，其它那些版本管理系统真的不想再动了。Git是我最喜欢的工具之一，另一个就是Emacs。
0x01 关键字 HEAD：指针 工作区 版本库(working tree) 暂存区(index)：add命令将文件添加到暂存区 已跟踪(staging)（未更新、已修改、已放入暂存区） 未跟踪(unstage) 仓库：commit将文件从暂存区添加到仓库 0x02 版本管理可以细分为 本地分支管理、远程分支管理、补丁管理、暂存（index）管理、
0x03 安装 如果你是在Debian，Ubuntu系统中，那么你可以通过下面命令安装：
sudo apt-get install git 如果你是在Red Hat，Fedora系统中，那么你可以通过下面命令安装：
sudo yum install git 我是通过下面这条命令来安装的：
pacman -S git 0x04 配置 git config --global user.name &amp;quot;name&amp;quot; git config --global user.email &amp;quot;name@gmail.com&amp;quot; git config --global color.ui true git config core.ignorecase false git config -l #list all the Git config 这样配置完后，保存在~/.</description></item></channel></rss>