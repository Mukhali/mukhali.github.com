<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>当然我在扯淡 on 当然我在扯淡</title><link>https://mukhali.github.io/</link><description>Recent content in 当然我在扯淡 on 当然我在扯淡</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 18 Apr 2019 22:55:46 +0800</lastBuildDate><atom:link href="/" rel="self" type="application/rss+xml"/><item><title>Win10和Ubuntu18.04多显卡的双系统安装</title><link>https://mukhali.github.io/2019/win10%E5%92%8Cubuntu18.04%E5%A4%9A%E6%98%BE%E5%8D%A1%E7%9A%84%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</link><pubDate>Thu, 18 Apr 2019 22:55:46 +0800</pubDate><guid>https://mukhali.github.io/2019/win10%E5%92%8Cubuntu18.04%E5%A4%9A%E6%98%BE%E5%8D%A1%E7%9A%84%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</guid><description>
&lt;p&gt;&lt;img src=&#34;https://mukhali.github.io/images/posts/beijingtravel.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;东京大学入学祝词：等着你的，是个努力也得不到回报的社会。&lt;/p&gt;
&lt;p&gt;爷爷说：在外面好好弄，莫担心他。(或许只有这些老人才让我有些动力，因为他们永远会觉得满足。)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-场景&#34;&gt;0x01 场景&lt;/h2&gt;
&lt;p&gt;两块 SSD 硬盘，准备装 Win 10 和 Ubuntu 18.04 双系统，每块硬盘分两个区：EFI 引导区和系统盘。&lt;/p&gt;
&lt;p&gt;先安装Win 10系统，后安装 Ubuntu 18.04。&lt;/p&gt;
&lt;h2 id=&#34;0x02-卡着&#34;&gt;0x02 卡着&lt;/h2&gt;
&lt;p&gt;Win 10 好安装，但当安装 Ubuntu 18.04 的时候会卡在 GUI 界面，鼠标和键盘都不能动。所以需要在
Ubuntu 进入 install Ubuntu 界面的时候按 e 键，将第二行的 quiet splash - - - 修改成 quiet splash nomodeset。nomodeset表示用电脑集显来进行显示。然后按F10继续安装。&lt;/p&gt;
&lt;h2 id=&#34;0x03-安装驱动&#34;&gt;0x03 安装驱动&lt;/h2&gt;
&lt;p&gt;安装好系统后，及需要安装显卡驱动了，要不然系统会很卡很卡。安装驱动大概有三种方法，选择一个有效
的就可以，不需要三个都用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;sudo apt-get update -y
sudo apt-get upgrade -y
ubuntu-drivers devices
sudo ubuntu-drivers autoinstall
sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;sudo apt-get update -y
sudo apt-get upgrade -y
sudo add-apt-repository -y ppa:graphics-drivers/ppa
sudo apt-get update -y
sudo ubuntu-drivers autoinstall
sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;从官方下载驱动安装
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x04-双启&#34;&gt;0x04 双启&lt;/h2&gt;
&lt;p&gt;安装好之后，每次启动还是只能进入 Ubuntu 系统，需要将 Win 10 加入 Ubuntu 的引导。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;sudo update-grub2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x05-碎碎念&#34;&gt;0x05 碎碎念&lt;/h2&gt;
&lt;p&gt;F2 用于修改 BIOS。&lt;/p&gt;
&lt;p&gt;F8 用于选择启动盘。&lt;/p&gt;
&lt;p&gt;制作系统盘的工具有很多。&lt;/p&gt;
&lt;p&gt;quiet splash &amp;mdash;（quiet splash acpi=off）&lt;/p&gt;
&lt;p&gt;quiet splash &amp;mdash;（quiet splash nomodeset）&lt;/p&gt;
&lt;p&gt;quiet splash &amp;mdash;（quiet splash i915.modeste=0 nouveau.modeset=0 nomodeset）&lt;/p&gt;
&lt;p&gt;lspci|grep -i nvidia&lt;/p&gt;
&lt;p&gt;dmesg|grep -i nvidia&lt;/p&gt;
&lt;p&gt;nvidia-smi&lt;/p&gt;
&lt;p&gt;sudo apt-get install ubuntu-drivers-common -y&lt;/p&gt;
&lt;p&gt;不做自己难受的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mukhali.github.io/images/posts/qrcode_for_gh_151.0.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description></item><item><title>Cpp语言回调函数</title><link>https://mukhali.github.io/2019/cpp%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 19 Feb 2019 23:04:40 +0800</pubDate><guid>https://mukhali.github.io/2019/cpp%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;想注册一个公众号，我好像文笔不是很好，我有很多内容可写，时间和文笔去哪儿找。&lt;/p&gt;
&lt;p&gt;Pytorch 1.0 才发布不久，但整个机器学习领域很成熟了，可以弥补不足。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-函数指针&#34;&gt;0x01 函数指针&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;struct IDataReader
{
virtual void ReadCallbackFunc(std::string topicName) = 0;
};
class Subscriber
{
public:
Subscriber();
~Subscriber();
bool SetCallback(IDataReader* iReader)
{
_process = iReader;
_process(&amp;quot;callback&amp;quot;);
return true;
}
private:
IDataReader * _process;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-cpp调用&#34;&gt;0x02 Cpp调用&lt;/h2&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;
class Example_Subscriber : IDataReader
{
public:
Example_Subscriber() {};
~Example_Subscriber();
void example_subscriber_main();
void CallbackFunc(std::string topicName);
private:
Subscriber * subscriberPtr;
};
Example_Subscriber::Example_Subscriber()
{
subscriberPtr = new Subscriber();
}
Example_Subscriber::~Example_Subscriber()
{
delete subscriberPtr;
}
void Example_Subscriber::example_subscriber_main()
{
subscriberPtr-&amp;gt;SetCallback(this);
}
void Example_Subscriber::CallbackFunc(std::string topicName)
{
printf(topicName);
}
int main()
{
Example_Subscriber * sub = new Example_Subscriber();
sub-&amp;gt;subscriber_main();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-update&#34;&gt;0x03 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;2019-03-01
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>C语言回调函数</title><link>https://mukhali.github.io/2019/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 19 Feb 2019 22:00:21 +0800</pubDate><guid>https://mukhali.github.io/2019/c%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单的事情，也需要有人去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-函数指针&#34;&gt;0x01 函数指针&lt;/h2&gt;
&lt;p&gt;C语言的回调函数主要通过函数指针的方式实现，相关主要代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef void(*CallbackFunc)(int mes_length);
void callback(int mes_length) // 回调函数
{
std::cout &amp;lt;&amp;lt; mes_length &amp;lt;&amp;lt;std::endl;
}
extern &amp;quot;C&amp;quot; void __declspec(dllimport) SetReadCallback(CallbackFunc callback) // 调用函数
{
int length = 0;
callback(length);
}
int main(int argc,char* argv[]) // 实现函数回调
{
SetReadCallback(callback);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-c调用&#34;&gt;0x02 C调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;void callback(int mes_length)
{
std::cout &amp;lt;&amp;lt; mes_length &amp;lt;&amp;lt;std::endl;
}
int main()
{
SetReadCallback(callback);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-c-调用&#34;&gt;0x03 C#调用&lt;/h2&gt;
&lt;p&gt;C#这边主要通过委托（delegate）来实现，具体代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;using System.Runtime.InteropServices;
namespace Test
{
class Program
{
[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
public delegate void CallbackFunc(int mes_length);
[DllImport(@&amp;quot;test.dll&amp;quot;, EntryPoint = &amp;quot;CCasicDDSCtrl2ModelSubscriberSharpSetCallback&amp;quot;,
SetLastError = true,CharSet = CharSet.Unicode, ExactSpelling = false,
CallingConvention = CallingConvention.Cdecl)]
extern static bool SetReadCallback(CallbackFunc callback);
static void Main(string[] args)
{
SetReadCallback(Program.CsharpCallback);
}
public static void CsharpCallback(int mes_length)
{
Console.WriteLine(mes_length);
}
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x04-update&#34;&gt;0x04 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;2019-02-19
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>C#调用Cpp语言DLL</title><link>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8cpp%E8%AF%AD%E8%A8%80dll/</link><pubDate>Mon, 18 Feb 2019 22:37:25 +0800</pubDate><guid>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8cpp%E8%AF%AD%E8%A8%80dll/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单的事情，也需要有人去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-cpp工程&#34;&gt;0x01 Cpp工程&lt;/h2&gt;
&lt;p&gt;CppMath.h&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#pragma once
#include &amp;lt;stdexcept&amp;gt;
class CppMath
{
public:
double Add(double arg1,double arg2);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CppMath.cpp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#pragma once
#include &amp;quot;CppMath.h&amp;quot;
double CppMath::Add(double arg1,double arg2)
{
return arg1+arg2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-clr-wrapper工程&#34;&gt;0x02 CLR Wrapper工程&lt;/h2&gt;
&lt;p&gt;CLRWrapper.h&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#pragma once
#include &amp;quot;CppMath.h&amp;quot;
using namespace System;
namespace CLRWrapper {
public ref class CppMathWrapper
{
public:
//ctor
CppMathWrapper();
//Methods
double Add(double arg1,double arg2);
private:
CppMath *cppMath;
};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CLRWrapper.cpp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;quot;stdafx.h&amp;quot;
#include &amp;quot;CLRWrapper.h&amp;quot;
#include &amp;quot;CppMath.cpp&amp;quot;
CLRWrapper::CppMathWrapper::CppMathWrapper()
{
cppMath = new CppMath();
}
double CLRWrapper::CppMathWrapper::Add(double arg1,double arg2)
{
return cppMath-&amp;gt;Add(arg1,arg2);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加头文件依赖&lt;/p&gt;
&lt;p&gt;Properties –&amp;gt; Configuration Properties –&amp;gt; C/C++ –&amp;gt; Additional Include Directories&lt;/p&gt;
&lt;h2 id=&#34;0x03-c-工程&#34;&gt;0x03 C#工程&lt;/h2&gt;
&lt;p&gt;添加引用&lt;/p&gt;
&lt;p&gt;prograss.cs&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;CppMathWrapper wrapper = new CppMathWrapper();
Console.WriteLine(wrapper.Add(1.4, 2.7));
Console.ReadLine();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x04-update&#34;&gt;0x04 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;2019-02-18
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>C#调用C语言DLL</title><link>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80dll/</link><pubDate>Mon, 18 Feb 2019 22:09:25 +0800</pubDate><guid>https://mukhali.github.io/2019/csharp%E8%B0%83%E7%94%A8c%E8%AF%AD%E8%A8%80dll/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单的事情，也需要有人去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-h文件&#34;&gt;0x01 .h文件&lt;/h2&gt;
&lt;p&gt;demo.h&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;extern &amp;quot;C&amp;quot; __declspec(dllexport) double Add(double a, double b);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-cpp文件&#34;&gt;0x02 .cpp文件&lt;/h2&gt;
&lt;p&gt;demo.cpp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;double Add( double a, double b ) { return a+b; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-c-实现&#34;&gt;0x03 C#实现&lt;/h2&gt;
&lt;p&gt;prograss.cs&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;using System.Runtime.InteropServices;
[DllImport(&amp;quot;MathFuncsDll.dll&amp;quot;, CallingConvention=CallingConvention.Cdecl)]
public static extern double Add(double a, double b);
public static void main()
{
c = Add(c, c);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x04-update&#34;&gt;0x04 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;2019-02-18
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>Golang的面向对象</title><link>https://mukhali.github.io/2019/golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link><pubDate>Sun, 13 Jan 2019 17:22:39 +0800</pubDate><guid>https://mukhali.github.io/2019/golang%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单的事情，也需要有人去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-成员变量&#34;&gt;0x01 成员变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;type Person struct {
name string
age int
}
person := Person{&amp;quot;mike&amp;quot;,18}
fmt.Println(person)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-成员函数&#34;&gt;0x02 成员函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;func (person *Person) showInfo() {
fmt.Printf(&amp;quot;My name is %s , age is %d &amp;quot;,person.name,person.age)
}
func (person *Person) setAge(age int) {
person.age = age
}
person := Person{&amp;quot;mike&amp;quot;,18}
person.showInfo()
person.setAge(20)
fmt,Println(person)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-继承&#34;&gt;0x03 继承&lt;/h2&gt;
&lt;p&gt;没有关键字的继承。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;type Student struct {
Person
id int
score int
}
func (student *Student) showInfo() {
fmt.Println(&amp;quot;I am a student ...&amp;quot;)
}
func (student *Student) read() {
fmt.Println(&amp;quot;read book ...&amp;quot;)
}
student := Student{Person{&amp;quot;jake&amp;quot;,16},1001,99}
student.showInfo()
student.setAge(22)
student.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x04-多态&#34;&gt;0x04 多态&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;package main
import &amp;quot;fmt&amp;quot;
type Human interface {
speak(language string)
}
type Chinese struct {
}
type American struct {
}
func (ch Chinese) speak(language string ) {
fmt.Printf(&amp;quot;speck %s\n&amp;quot;,language)
}
func (am American ) speak(language string ) {
fmt.Printf(&amp;quot;speck %s\n&amp;quot;,language)
}
func main() {
var ch Human
var am Human
ch = Chinese{}
am = American{}
ch.speak(&amp;quot;Chinese&amp;quot;)
am.speak(&amp;quot;English&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>Golang操作Sqlite</title><link>https://mukhali.github.io/2019/golang%E6%93%8D%E4%BD%9Csqlite/</link><pubDate>Sun, 13 Jan 2019 11:08:30 +0800</pubDate><guid>https://mukhali.github.io/2019/golang%E6%93%8D%E4%BD%9Csqlite/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单的事情，也需要有人去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-代码&#34;&gt;0x01 代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;package main
import (
&amp;quot;database/sql&amp;quot;
&amp;quot;fmt&amp;quot;
_ &amp;quot;github.com/mattn/go-sqlite3&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
type Person struct {
name string
age int
}
person := Person{&amp;quot;mike&amp;quot;,18}
fmt.Println(person)
os.Remove(&amp;quot;./foo.db&amp;quot;)
db, err := sql.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;./foo.db&amp;quot;)
checkErr(err)
defer db.Close()
//插入数据
_, err = db.Exec(&amp;quot;create table userinfo (uid text not null primary key, username text, departname text, created text)&amp;quot;)
checkErr(err)
stmt, err := db.Prepare(&amp;quot;INSERT INTO userinfo(uid, username, departname, created) values(?,?,?,?)&amp;quot;)
checkErr(err)
defer stmt.Close()
res, err := stmt.Exec(&amp;quot;1&amp;quot;, &amp;quot;astaxie&amp;quot;, &amp;quot;研发部门&amp;quot;, &amp;quot;2012-12-09&amp;quot;)
checkErr(err)
id, err := res.LastInsertId()
checkErr(err)
fmt.Println(id)
//更新数据
stmt, err = db.Prepare(&amp;quot;update userinfo set username=? where uid=?&amp;quot;)
checkErr(err)
defer stmt.Close()
res, err = stmt.Exec(&amp;quot;astaxieupdate&amp;quot;, id)
checkErr(err)
affect, err := res.RowsAffected()
checkErr(err)
fmt.Println(affect)
//查询数据
rows, err := db.Query(&amp;quot;SELECT * FROM userinfo&amp;quot;)
checkErr(err)
defer rows.Close()
for rows.Next() {
var uid int
var username string
var department string
var created string
err = rows.Scan(&amp;amp;uid, &amp;amp;username, &amp;amp;department, &amp;amp;created)
checkErr(err)
fmt.Println(uid)
fmt.Println(username)
fmt.Println(department)
fmt.Println(created)
}
//删除数据
stmt, err = db.Prepare(&amp;quot;delete from userinfo where uid=?&amp;quot;)
checkErr(err)
defer stmt.Close()
res, err = stmt.Exec(id)
checkErr(err)
affect, err = res.RowsAffected()
checkErr(err)
fmt.Println(affect)
db.Close()
}
func checkErr(err error) {
if err != nil {
panic(err)
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-错误处理&#34;&gt;0x02 错误处理&lt;/h2&gt;
&lt;p&gt;Golang 的这种检查错误的代码太多了，过度重复，一点都不优雅。Golang 2 对这种情况进行了改善。draft 给出的例子如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;func main() {
hex, err := ioutil.ReadAll(os.Stdin)
if err != nil {
log.Fatal(err)
}
data, err := parseHexdump(string(hex))
if err != nil {
log.Fatal(err)
}
os.Stdout.Write(data)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Golang 2的写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;func main() {
handle err {
log.Fatal(err)
}
hex := check ioutil.ReadAll(os.Stdin)
data := check parseHexdump(string(hex))
os.Stdout.Write(data)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-update&#34;&gt;0x03 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;2019-01-15
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>Sqlite3数据库合并</title><link>https://mukhali.github.io/2019/sqlite3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E5%B9%B6/</link><pubDate>Wed, 09 Jan 2019 16:02:17 +0800</pubDate><guid>https://mukhali.github.io/2019/sqlite3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%88%E5%B9%B6/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再简单的事情，也需要有人去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-需求&#34;&gt;0x01 需求&lt;/h2&gt;
&lt;p&gt;存在多个数据库，需要合并，数据库中相同表的结构是一样的。
主要是使用了Sqlite3的系统表sqlite_master。&lt;/p&gt;
&lt;h2 id=&#34;0x02-python-代码&#34;&gt;0x02 Python 代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;
# coding=utf-8
import sys, sqlite3, os
def merge_tables(tables_file_a, tables_file_b, con_file_a):
print(&amp;quot;Start Merge Tables&amp;quot;)
j = 0
while j &amp;lt; len(tables_file_b):
if not tables_file_b[j] in tables_file_a:
cur_table_file_a = con_file_a.cursor()
try:
cur_table_file_a.execute(tables_file_b[j][3:-3])
except:
print(&amp;quot;Error: &amp;quot; + tables_file_b[j][3:-3])
j += 1
else:
j += 1
print(&amp;quot;All Tables Merged!&amp;quot;)
def merge_index(tables_file_a, tables_file_b, con_file_a):
print(&amp;quot;Start Merge Index&amp;quot;)
j = 0
while j &amp;lt; len(tables_file_b):
if not tables_file_b[j] in tables_file_a:
cur_table_file_a = con_file_a.cursor()
try:
cur_table_file_a.execute(tables_file_b[j][3:-3])
except:
print(&amp;quot;Error: &amp;quot; + tables_file_b[j][3:-3])
j += 1
else:
j += 1
print(&amp;quot;All Index Merged!&amp;quot;)
def merge_data(con_current_data, con_des_data, tables_current_data):
m = 0
cur_current_data = con_current_data.cursor()
while m &amp;lt; len(tables_current_data):
sql_statement = &amp;quot;select * from &amp;quot; + tables_current_data[m][3:-3]
cur_current_data.execute(sql_statement)
temp_data_list = cur_current_data.fetchall()
n = 0
cur_des_data = con_des_data.cursor()
while n &amp;lt; len(temp_data_list):
sql_exist_statement = &amp;quot;select * from &amp;quot; \
+ str(tables_current_data[m])[3:-3] + \
&#39; where COL_UID=&amp;quot;&#39; + temp_data_list[n][0] + &#39;&amp;quot;&#39;
cur_des_data.execute(sql_exist_statement)
temp_des_data_list = cur_des_data.fetchall()
cur_des_next_data = con_des_data.cursor()
if len(temp_des_data_list) == 0:
sql_temp = &amp;quot;&amp;quot;
nn = 0
try:
while nn &amp;lt; len(temp_data_list[n]):
sql_statement += &#39;&amp;quot;&#39; + temp_data_list[n][nn] + &#39;&amp;quot;,&#39;
nn += 1
except:
print(&amp;quot;Error &amp;quot; + sql_temp)
try:
cur_des_next_data.execute(&amp;quot;insert into &amp;quot;
+ str(tables_current_data[m])[3:-3]
+ &amp;quot; values(&amp;quot; + sql_temp[0:-1] + &amp;quot;)&amp;quot;)
cur_des_next_data.commit()
except:
print(&amp;quot;Error &amp;quot; + sql_temp)
n += 1
else:
n += 1
m += 1
print(&amp;quot;All Tables Data Merged!&amp;quot;)
con_file_a = sqlite3.connect(&amp;quot;~/a.db&amp;quot;)
con_file_b = sqlite3.connect(&amp;quot;~/b.db&amp;quot;)
# 处理表
sql_table_statement = &amp;quot;select sql From sqlite_master Where type=&#39;table&#39;&amp;quot;
cur_file_a = con_file_a.cursor()
cur_file_a.execute(sql_table_statement)
tables_file_a = cur_file_a.fetchall()
cur_file_b = con_file_b.cursor()
cur_file_b.execute(sql_table_statement)
tables_file_b = cur_file_b.fetchall()
merge_tables(tables_file_a, tables_file_b, con_file_a)
# 处理索引
sql_index_statement = &amp;quot;select sql From sqlite_master Where type=&#39;index&#39;&amp;quot;
cur_file_a = con_file_a.cursor()
cur_file_a.execute(sql_index_statement)
tables_file_a = cur_file_a.fetchall()
cur_file_b = con_file_b.cursor()
cur_file_b.execute(sql_index_statement)
tables_file_b = cur_file_b.fetchall()
merge_index(tables_file_a, tables_file_b, con_file_a)
con_file_a.close()
con_file_b.close()
sql_data_statement = &amp;quot;SELECT name FROM sqlite_master WHERE type=&#39;table&#39;&amp;quot;
cur_file_a = con_file_a.cursor()
cur_file_a.execute(sql_data_statement)
cur_file_b = con_file_b.cursor()
cur_file_b.execute(sql_data_statement)
tables_file_b = cur_file_b.fetchall()
merge_data(con_file_b, con_file_a, tables_file_b)
print(&amp;quot;---------All Data Finished!--------&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-后记&#34;&gt;0x03 后记&lt;/h2&gt;
&lt;p&gt;开始用Python做了这一版，后来用 Qt 重做了，所以这个最初版就放出来了。&lt;/p&gt;
&lt;h2 id=&#34;0x04-update&#34;&gt;0x04 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;2019-01-13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://mukhali.github.io/images/posts/qrcode_for_gh_151.0.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description></item><item><title>2018年的杂记</title><link>https://mukhali.github.io/2018/2018%E5%B9%B4de%E6%9D%82%E8%AE%B0/</link><pubDate>Mon, 31 Dec 2018 17:08:39 +0800</pubDate><guid>https://mukhali.github.io/2018/2018%E5%B9%B4de%E6%9D%82%E8%AE%B0/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;每个人都有缺点，我也不例外。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-只言片语&#34;&gt;0x01 只言片语&lt;/h2&gt;
&lt;p&gt;又是一年过去了，我也已经过三十了。&lt;/p&gt;
&lt;p&gt;今年自己想做的都做了吗？好像没有，只是时间已经流逝。&lt;/p&gt;
&lt;p&gt;回头看毕业两年，未来该怎么走？我不知道，我只知道我该往前使劲走。&lt;/p&gt;
&lt;p&gt;如果我是一匹野马，自该有自己的草原，如果没有，我将去寻找。&lt;/p&gt;
&lt;p&gt;2018 电脑、手机……&lt;/p&gt;
&lt;p&gt;2019年我该往哪儿使劲？&lt;/p&gt;
&lt;p&gt;我一定要去做云开发，基于Golang……寻找自己的草原&lt;/p&gt;
&lt;p&gt;努力去做吧，谁又曾知道。&lt;/p&gt;</description></item><item><title>洗衣机的选择</title><link>https://mukhali.github.io/2018/%E6%B4%97%E8%A1%A3%E6%9C%BAde%E9%80%89%E6%8B%A9/</link><pubDate>Mon, 31 Dec 2018 11:19:37 +0800</pubDate><guid>https://mukhali.github.io/2018/%E6%B4%97%E8%A1%A3%E6%9C%BAde%E9%80%89%E6%8B%A9/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以前不懂，以后就懂了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-关于洗衣机&#34;&gt;0x01 关于洗衣机&lt;/h2&gt;
&lt;p&gt;店里的洗衣机停工快一年了，最近天气变冷，在给店了挑选洗衣机。以前不懂洗衣机器，最近查了一下，考虑到空间和合用性，最后选了海尔。&lt;/p&gt;
&lt;p&gt;市场上的情况是：海尔洗衣机市场占有率第一、小天鹅专做洗衣机，18年被美的收购、容声是做冰箱出身的。&lt;/p&gt;
&lt;p&gt;洗衣机可以分两类：波轮式和滚筒式。我喜欢滚筒样式。&lt;/p&gt;
&lt;p&gt;我以前不懂，以后就懂了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mukhali.github.io/images/posts/washing_machine.jpeg&#34; width=&#34;50%&#34; height=&#34;50%&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;0x2-update&#34;&gt;0x2 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; 2018-12-31
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>About</title><link>https://mukhali.github.io/about/</link><pubDate>Mon, 24 Dec 2018 11:38:26 +0800</pubDate><guid>https://mukhali.github.io/about/</guid><description>&lt;p&gt;您好！我不知道这是什么？&lt;/p&gt;
&lt;p&gt;人越长大越不敢说自己会什么，简历中技能部分我会试着去不断的删减……&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;突然想起某人曾说：慢慢来，会比较快。&lt;/p&gt;
&lt;p&gt;人到中年，开始老了，也更软了。经历的事情越多，越来越不敢嘲笑别人的脆弱。也越来越像个历史唯物主义者，相信常识，相信事物的客观规律。&lt;/p&gt;
&lt;p&gt;环看周遭的人，哪一个不是千疮百孔。&lt;/p&gt;
&lt;p&gt;我以前太刚了，相信自己一定是个幸运者，玩三国杀的时候喜欢用夏侯淳的“刚烈”，总之做不到温如玉。&lt;/p&gt;
&lt;p&gt;过去总想让世界知道我，现在就希望这个世界忘记我，然后慢慢等待80岁的自己，会不会活的比爷爷或外公更舒适？&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Surely！！！！！ I Am Joking&lt;/p&gt;</description></item><item><title>Emacs喜欢神器</title><link>https://mukhali.github.io/2016/emacs%E5%96%9C%E6%AC%A2%E7%A5%9E%E5%99%A8/</link><pubDate>Tue, 08 Mar 2016 20:19:37 +0800</pubDate><guid>https://mukhali.github.io/2016/emacs%E5%96%9C%E6%AC%A2%E7%A5%9E%E5%99%A8/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Emacs是一个操作系统级别Editor，最初由Richard Stallman(理查德·马修·斯托曼)于1975年在MIT协同Guy Steele共同完成。很可能有人喜欢UNIX哲学，而讨厌Emacs这种包含万物的行为。而我会说“我喜欢UNIX哲学，也拥抱Emacs”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-appointment&#34;&gt;0x01 Appointment&lt;/h2&gt;
&lt;p&gt;在diary文件中编辑你的安排如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; Monday
8:00am 该工作咯
3:00pm 看会儿paper
Tuesday
8:00am 该工作咯
3:00pm 看会儿paper
Wednesday
8:00am 该工作咯
3:00pm 看会儿paper
Thursday
8:00am 该工作咯
3:00pm 看会儿paper
Friday
8:00am 该工作咯
3:00pm 看会儿paper
* 1 清理一遍阅读列表，学习一个新主题
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在你自己的配置文件中添加以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; (global-set-key (kbd &amp;quot;&amp;lt;f9&amp;gt;&amp;quot;)
&#39;(lambda () (interactive)
(progn
(if (not (featurep &#39;appt))
(appt-activate)
(unless appt-timer
(appt-activate)))
))) ;quick access to Calendar and Diary
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次打开Emacs的时候，按f9就能激活提醒了。&lt;/p&gt;
&lt;h2 id=&#34;0x02-calendar&#34;&gt;0x02 Calendar&lt;/h2&gt;
&lt;p&gt;在生活中总有些节日不能错过，
在过往的时间中总有些日子不能忘怀，
在这世间总有些人不能不挂念，&lt;/p&gt;
&lt;p&gt;那么cal-china-x就能登上舞台，解决你的这些问题了，它可以记录农历的节日，也可以记录阳历。每天打开Emacs就能看到近日的重要事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; (if (&amp;lt; (string-to-number (format-time-string &amp;quot;%H&amp;quot;)) 9)
(calendar)
(switch-to-buffer &amp;quot;*scratch*&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x03-writeroom-mode&#34;&gt;0x03 writeroom mode&lt;/h2&gt;
&lt;p&gt;当你在写作或者编码时，是不是不喜欢被打扰？那么这个包就是你想要的。还记当年流行全屏写作软件，到处找软件的日子吗？有过iA Writer使用经历吗？&lt;/p&gt;
&lt;p&gt;在Emacs中，你安装writeroom包后，就能完全沉浸在自己快乐写作或编码中，不会有任何打扰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/673794-b25d5f45d64087d1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Emacs写作&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;0x04-focus-mode&#34;&gt;0x04 focus mode&lt;/h2&gt;
&lt;p&gt;当你写作或者编码时，是不是想减少关注点？那么focus包就是你要的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/673794-7f7d53db072adbe6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Emacs专注&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;0x05-auctex&#34;&gt;0x05 Auctex&lt;/h2&gt;
&lt;p&gt;在使用Emacs之前，我一直使用TeXstudio作为TeXLive的前端，写作时使用Sublime。当你遇见Auctex时，你会喜欢上她的。&lt;/p&gt;
&lt;h2 id=&#34;0x06-time-format&#34;&gt;0x06 Time Format&lt;/h2&gt;
&lt;p&gt;当你全屏Emacs后，无法看到时间，你可以通过这个在mode line上看到时间奥。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; (setq display-time-24hr-format t
;; display-time-format &amp;quot;%d | %H:%M&amp;quot;
;; display-time-day-and-date t
;; display-time-interval 60
display-time-default-load-average nil)
(display-time-mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x07-org-pomodoro&#34;&gt;0x07 Org Pomodoro&lt;/h2&gt;
&lt;p&gt;org-pomodoro自带的显示样式，太长。占地方，我需要短些的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; (custom-set-variables
&#39;(org-pomodoro-format &amp;quot;•%s&amp;quot;)
&#39;(org-pomodoro-short-break-format &amp;quot;•%s&amp;quot;) )
(add-hook &#39;org-pomodoro-finished-hook
(lambda ()
(mukhali/terminal-notifier-notify &amp;quot;Pomodoro&amp;quot; &amp;quot;time-for-relax&amp;quot;)))
(add-hook &#39;org-pomodoro-short-break-finished-hook
(lambda ()
(mukhali/terminal-notifier-notify &amp;quot;Break-Completed&amp;quot; &amp;quot;ready-for-another?&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/673794-5c1cbfd6ee0cb8d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;定制后的显示样式&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;0x08-org-todo&#34;&gt;0x08 Org Todo&lt;/h2&gt;
&lt;p&gt;任何事物默认设置永远不会是你想要的，就像QQ默认设置一样：不断打扰你，不断让你去社交。&lt;/p&gt;
&lt;p&gt;Org 的设置还是需要定制的，根据自己的需求，使用频率去定制自己的方式。下面是我的一些基本定制内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; (define-key global-map (kbd &amp;quot;&amp;lt;f7&amp;gt;&amp;quot;) &#39;org-agenda-list)
(define-key global-map (kbd &amp;quot;&amp;lt;f9&amp;gt;&amp;quot;)
(lambda () (interactive) (org-capture nil &amp;quot;w&amp;quot;)))
(with-eval-after-load &#39;org-agenda
(define-key org-agenda-mode-map (kbd &amp;quot;P&amp;quot;) &#39;org-pomodoro))
;; (setq org-directory &amp;quot;~/org/&amp;quot;)
(setq org-deadline-warning-days 4)
(setq org-agenda-files (list
&amp;quot;~/org/works.org&amp;quot;))
(setq org-src-fontify-natively t)
;; (setq org-default-notes-file (concat org-directory &amp;quot;notes.org&amp;quot;))
;; (setq org-agenda-include-diary t)
(setq org-refile-targets
&#39;((nil :maxlevel . 5) (org-agenda-files :maxlevel . 5)))
(setq org-todo-keywords
&#39;((sequence &amp;quot;TODO(t)&amp;quot; &amp;quot;|&amp;quot; &amp;quot;DONE(d)&amp;quot; &amp;quot;CANCELED(c)&amp;quot;)))
(setq org-capture-templates
&#39;((&amp;quot;w&amp;quot; &amp;quot;I always arrive late at the office,
but I make up for it by leaving early.&amp;quot;
entry (file+headline &amp;quot;works.org&amp;quot; &amp;quot;Works&amp;quot;)
&amp;quot;* TODO %?\n %i\n SCHEDULED: %t\n %a&amp;quot; :empty-lines 1)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x09-windows-notifier&#34;&gt;0x09 Windows notifier&lt;/h2&gt;
&lt;p&gt;不喜欢Emacs自带的notifier，感谢开源运动，让我有解决方案可选。下面是我的定制。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; (setq terminal-notifier-command
&amp;quot;~/plugins/growlnotify.exe&amp;quot;)
(defun mukhali/terminal-notifier-notify (title message)
(shell-command-to-string
(concat terminal-notifier-command
&amp;quot; /t:&amp;quot; title
&amp;quot; /i:&amp;quot; &amp;quot;~/plugins/emacs.png&amp;quot;)
&amp;quot; &amp;quot; message)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x10-杂项&#34;&gt;0x10 杂项&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;;; Emacs 启动时所在的位置
(setq default-frame-alist &#39;((left . 0) (top . 0) (width . 80) (height . 38)))
;; 自己的一些Windows使用习惯
(define-key global-map (kbd &amp;quot;M-&amp;lt;f4&amp;gt;&amp;quot;)
(lambda () (interactive)
(recentf-cleanup)
(projectile-cleanup-known-projects)
(spacemacs/save-buffers-kill-emacs)
) )
(define-key global-map (kbd &amp;quot;M-C-q&amp;quot;) &#39;winner-undo)
(global-unset-key (kbd &amp;quot;C-x C-s&amp;quot;))
(global-set-key (kbd &amp;quot;C-s&amp;quot;) &#39;save-buffer)
;; 一些常用函数
(defun mukhali/quick-folding-source ()
(interactive)
(set-selective-display
(if selective-display nil 1)))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x11-update&#34;&gt;0x11 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;2016-03-08
2016-04-20
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>Git喜欢版本管理</title><link>https://mukhali.github.io/2016/git%E5%96%9C%E6%AC%A2%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</link><pubDate>Tue, 19 Jan 2016 09:51:04 +0800</pubDate><guid>https://mukhali.github.io/2016/git%E5%96%9C%E6%AC%A2%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</guid><description>
&lt;h2 id=&#34;0x00-引言&#34;&gt;0x00 引言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Git是一个分布式版本控制／软件配置管理软件，原是Linux内核开发者林纳斯·托瓦兹（Linus Torvalds）为更好地管理Linux内核开发而设计。本文记录了一些基本概念和基本操作，当然关于使用 Git 最重要的其实不是明白这些，而是掌握一些Git的使用模式。
当你用上了Git，其它那些版本管理系统真的不想再动了。Git是我最喜欢的工具之一，另一个就是Emacs。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;0x01-关键字&#34;&gt;0x01 关键字&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; HEAD：指针
工作区
版本库(working tree)
暂存区(index)：add命令将文件添加到暂存区
已跟踪(staging)（未更新、已修改、已放入暂存区）
未跟踪(unstage)
仓库：commit将文件从暂存区添加到仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x02-版本管理可以细分为&#34;&gt;0x02 版本管理可以细分为&lt;/h2&gt;
&lt;p&gt;本地分支管理、远程分支管理、补丁管理、暂存（index）管理、&lt;/p&gt;
&lt;h2 id=&#34;0x03-安装&#34;&gt;0x03 安装&lt;/h2&gt;
&lt;p&gt;如果你是在Debian，Ubuntu系统中，那么你可以通过下面命令安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; sudo apt-get install git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你是在Red Hat，Fedora系统中，那么你可以通过下面命令安装：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; sudo yum install git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我是通过下面这条命令来安装的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; pacman -S git
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x04-配置&#34;&gt;0x04 配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git config --global user.name &amp;quot;name&amp;quot;
git config --global user.email &amp;quot;name@gmail.com&amp;quot;
git config --global color.ui true
git config core.ignorecase false
git config -l #list all the Git config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样配置完后，保存在~/.gitconfig&lt;/p&gt;
&lt;h2 id=&#34;0x05-查看帮助&#34;&gt;0x05 查看帮助&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git help
git help -show #查看show命令的子命令
git add -h #查看git add命令的帮助文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x06-常用命令-查看-添加-提交-删除-找回-重置&#34;&gt;0x06 常用命令（查看、添加、提交、删除、找回、重置）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git show 356f6def9d3fb7f3b9032ff5aa4b9110d4cca87e
#（哈希值，可以是具体某个文件的，也可以是某一次全部提交）
checkout #重写工作区
git co（git co HEAD） #汇总显示工作区、暂存区与HEAD的差异
git co master #取出master版本的HEAD
git co -- filename #把filename文件从HEAD中checkouut。
#相当于取消自上次执行git add filename以来的本地修改。
git co branch --filename #用branch分支filename 来替换暂存区和工作区文件。
git co . (git co -- .) #用暂存区的文件代替所有现有项目文件。
git add #命令主要用于把我们要提交的文件的信息添加到索引库(暂存区)中。
#当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。
git add filename
git add . #将修改过的工作文件提交暂存区
git add -u
#表示 add to index only files modified or deleted and not those created
git add -i [&amp;lt;path&amp;gt;] #命令查看&amp;lt;path&amp;gt;中被所有修改过或已删除文件但没有提交的文件。
git ci #是将那些已经add到暂存区的文件commit到库中。
git ci filemame
git ci .
git ci -a #将git add, git rm和git commit等操作都合并在一起做。
git ci -m &amp;quot;what u want to &amp;quot;
git ci -am &amp;quot;what u want to &amp;quot;
git ci -amend #?
git rm filename #删除文件，并从版本库中删除。
git rm -r dire #删除文件，并从库中移除。
git rm filename --cached #从版本库中删除文件，但不删除文件。
reset #命令可以去掉一些多余的状态和版本信息。
git reset [--hard|soft|mixed|merge|keep] [brank or HEAD] #reset命令是有mode的。
git reset filename
git reset -- .
git resert --hard #恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
git revert
#撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交
git revert HEAD #撤销前一次commit
git revert HEAD^ #撤销前前一次commit
git revert &amp;lt;id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x07-查看文件的不同&#34;&gt;0x07 查看文件的不同&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git diff filename #比较当前文件（工作区文件）和暂存区（索引区）文件的差异。
git diff &amp;lt;id&amp;gt; &amp;lt;id&amp;gt; #比较两次提交之间的差异
git diff &amp;lt;branch1&amp;gt;..&amp;lt;branch2&amp;gt; # 在两个分支之间比较
git diff --staged # 比较暂存区和版本库差异
git diff --cached # 比较暂存区和版本库差异
git diff --stat # 仅仅比较统计信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x08-查看提交记录&#34;&gt;0x08 查看提交记录&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git lg
git lg &amp;lt;file&amp;gt; # 查看该文件每次提交记录
git lg -p &amp;lt;file&amp;gt; # 查看每次详细修改内容的diff
git lg -p -2 # 查看最近两次详细修改内容的diff
git lg --stat # 查看提交统计信息
git lg --pretty=oneline --graph #精简信息显示方式
git lg --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot; --graph
git lg --pretty=oneline filename
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x09-本地分支管理&#34;&gt;0x09 本地分支管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git branch -r
git br -r # 查看远程分支
git br &amp;lt;new_branch&amp;gt; # 创建新的分支
git br -v # 查看各个分支最后提交信息
git br --merged # 查看已经被合并到当前分支的分支
git br --no-merged # 查看尚未被合并到当前分支的分支
git co &amp;lt;branch&amp;gt; # 切换到某个分支
git co -b &amp;lt;new_branch&amp;gt; # 创建新的分支，并且切换过去
git co -b &amp;lt;new_branch&amp;gt; &amp;lt;branch&amp;gt; # 基于branch创建新的new_branch
git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除
git co $id -b &amp;lt;new_branch&amp;gt; # 把某次历史提交记录checkout出来，创建成一个分支
git br -d &amp;lt;branch&amp;gt; # 删除某个分支
git br -D &amp;lt;branch&amp;gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x10-分支合并和rebase&#34;&gt;0x10 分支合并和rebase&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git merge &amp;lt;branch&amp;gt; # 将branch分支合并到当前分支
git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交
git rebase master &amp;lt;branch&amp;gt; # 将master rebase到branch，相当于：
git co &amp;lt;branch&amp;gt; &amp;amp;&amp;amp; git rebase master &amp;amp;&amp;amp; git co master &amp;amp;&amp;amp; git merge &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x11-补丁管理&#34;&gt;0x11 补丁管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git diff &amp;gt; ../sync.patch # 生成补丁
git apply ../sync.patch # 打补丁
git apply --check ../sync.patch # 测试补丁能否成功
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x12-暂存管理&#34;&gt;0x12 暂存管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git stash # 暂存
git stash list # 列所有stash
git stash apply # 恢复暂存的内容
git stash drop # 删除暂存区
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x13-远程分支管理&#34;&gt;0x13 远程分支管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git pull # 抓取远程仓库所有分支更新并合并到本地
git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并
git fetch origin # 抓取远程仓库更新
git merge origin/master # 将远程主分支合并到本地当前分支
git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支
git co -b &amp;lt;local_branch&amp;gt; origin/&amp;lt;remote_branch&amp;gt; # 基于远程分支创建本地分支，功能同上
git push # push所有分支
git push origin master # 将本地主分支推到远程主分支
git push -u origin master
# 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)
git push origin &amp;lt;local_branch&amp;gt; # 创建远程分支， origin是远程仓库名
git push origin &amp;lt;local_branch&amp;gt;:&amp;lt;remote_branch&amp;gt; # 创建远程分支
git push origin :&amp;lt;remote_branch&amp;gt;
#先删除本地分支(git br -d &amp;lt;branch&amp;gt;)，然后再push删除远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x14-远程仓库管理&#34;&gt;0x14 远程仓库管理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git remote -v # 查看远程服务器地址和仓库名称
git remote show origin # 查看远程服务器仓库状态
git remote add origin git@github:robbin/robbin_site.git
# 添加远程仓库地址
git remote set-url origin git@github.com:robbin/robbin_site.git
# 设置远程仓库地址(用于修改远程仓库地址)
git remote rm &amp;lt;repository&amp;gt; # 删除远程仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x15-创建远程仓库&#34;&gt;0x15 创建远程仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库
scp -r my_project.git git@git.csdn.net:~ # 将纯仓库上传到服务器上
mkdir robbin_site.git &amp;amp;&amp;amp; cd robbin_site.git &amp;amp;&amp;amp; git --bare init # 在服务器创建纯仓库
git remote add origin git@github.com:robbin/robbin_site.git # 设置远程仓库地址
git push -u origin master # 客户端首次提交
git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track
git remote set-head origin master # 设置远程仓库的HEAD指向master分支
#也可以命令设置跟踪远程库和本地库
git br --set-upstream master origin/master
git br --set-upstream develop origin/develop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;0x16-update&#34;&gt;0x16 UPDATE&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt; 2016-01-19（还有一部分设置没有更新）
&lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>